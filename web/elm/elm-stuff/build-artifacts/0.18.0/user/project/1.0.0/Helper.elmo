var _user$project$Helper$ms = _elm_lang$core$Time$millisecond;
var _user$project$Helper$fromDegrees = _elm_lang$core$Basics$degrees;
var _user$project$Helper$cycle = F2(
	function (n, xs) {
		return A2(
			_elm_lang$core$Basics_ops['++'],
			A2(_elm_lang$core$List$drop, n, xs),
			A2(_elm_lang$core$List$take, n, xs));
	});
var _user$project$Helper$mapBoth = F2(
	function (f, _p0) {
		var _p1 = _p0;
		return {
			ctor: '_Tuple2',
			_0: f(_p1._0),
			_1: f(_p1._1)
		};
	});
var _user$project$Helper$mapFirst = F2(
	function (f, xs) {
		var _p2 = xs;
		if (_p2.ctor === '[]') {
			return {ctor: '[]'};
		} else {
			return {
				ctor: '::',
				_0: f(_p2._0),
				_1: _p2._1
			};
		}
	});
var _user$project$Helper_ops = _user$project$Helper_ops || {};
_user$project$Helper_ops['%%'] = F2(
	function (x, y) {
		return A2(
			F2(
				function (x, y) {
					return x + y;
				}),
			x - _elm_lang$core$Basics$toFloat(
				_elm_lang$core$Basics$floor(x)),
			_elm_lang$core$Basics$toFloat(
				A2(
					_elm_lang$core$Basics_ops['%'],
					_elm_lang$core$Basics$floor(x),
					y)));
	});
var _user$project$Helper_ops = _user$project$Helper_ops || {};
_user$project$Helper_ops['+:'] = F2(
	function (xs, x) {
		return A2(
			_elm_lang$core$Basics_ops['++'],
			xs,
			{
				ctor: '::',
				_0: x,
				_1: {ctor: '[]'}
			});
	});
var _user$project$Helper$fl = _elm_lang$core$Basics$flip;
var _user$project$Helper$mResolveList = A3(
	_user$project$Helper$fl,
	_elm_lang$core$List$foldr,
	{ctor: '[]'},
	function (_p3) {
		return F2(
			function (x, y) {
				return A2(_elm_lang$core$Basics_ops['++'], x, y);
			})(
			A3(
				_elm_community$maybe_extra$Maybe_Extra$unwrap,
				{ctor: '[]'},
				_elm_lang$core$List$singleton,
				_p3));
	});
var _user$project$Helper$toDegrees = function (_p4) {
	return A3(
		_user$project$Helper$fl,
		F2(
			function (x, y) {
				return x / y;
			}),
		180,
		A2(
			F2(
				function (x, y) {
					return x * y;
				}),
			_elm_lang$core$Basics$pi,
			_p4));
};
